/* 
Цельсій у Фаренгейт
Формула для конвертації Цельсію у Фаренгейт: температура в Цельсіях × 9/5 + 32.
Вам надано змінну celsius, яка відповідає температурі за Цельсієм. Використайте вже визначену змінну fahrenheit та призначте
 їй температуру за Фаренгейтом, еквівалентну заданій температурі за Цельсієм. Використайте запропоновану вище формулу для 
 конвертації температури за Цельсієм у температуру за Фаренгейтом.
 */

function convertCtoF(celsius) {
  let fahrenheit = celsius * (9 / 5) + 32;
  return fahrenheit;
}

// Change the inputs below to test your code
convertCtoF(30);

//******************************************************************************************************************************
/*
Зворотний рядок
Переверніть наданий рядок та поверніть рядок у зворотньому порядку.

Наприклад, "hello" повинен стати "olleh". 
 */

function reverseString(str) {
  return str.split("").reverse().join("");
}

reverseString("hello");
//******************************************************************************************************************************
/* Факторизація числа
Поверніть факторіал поданого цілого числа.

Якщо ціле число позначається літерою n, то факторіал — це добуток усіх додатних цілих чисел, менших або рівних n.

Факторіали часто зображаються короткими позначеннями n!

Наприклад: 5! = 1 * 2 * 3 * 4 * 5 = 120

Функції будуть задані тільки ті цілі числа, які більші або дорівнюють нулю. */
//loop solution
// function factorialize(num) {
//   let result = 1;
//   for (let i = 2; i <= num; i++) {
//     result *= i;
//   }
//   return result;
// }

// factorialize(5);

//recursive solution
function factorialize(num) {
  if (num <= 0) {
    return 1;
  }
  return num * factorialize(num - 1);
}

factorialize(5);
//******************************************************************************************************************************
/* 
Пошук найдовшого слова в рядку
Поверніть довжину найдовшого слова у даному реченні.

Ваша відповідь повинна бути числом. */

//1 solution
// function findLongestWordLength(str) {
//   // split the string into individual words
//   const words = str.split(" ");

//   // words only has 1 element left that is the longest element
//   if (words.length == 1) {
//     return words[0].length;
//   }

//   // if words has multiple elements, remove the first element
//   // and recursively call the function
//   return Math.max(
//     words[0].length,
//     findLongestWordLength(words.slice(1).join(" "))
//   );
// }

// findLongestWordLength("The quick brown fox jumped over the lazy dog");

//map solution
function findLongestWordLength(str) {
  return Math.max(...str.split(" ").map((word) => word.length));
}
//******************************************************************************************************************************
/* Повернення найбільших чисел у масивах
Поверніть масив, який містить найбільше число з кожного наданого підмасиву. Для спрощення: наданий масив міститиме 4 підмасиви.

Пам’ятайте, ви можете перебрати масив за допомогою циклу for та мати доступ до кожного елемента завдяки синтаксису масиву arr[i]. */

function largestOfFour(arr) {
  return arr.map((item) => Math.max(...item));
}

largestOfFour([
  [4, 5, 1, 3],
  [13, 27, 18, 26],
  [32, 35, 37, 39],
  [1000, 1001, 857, 1],
]);
//******************************************************************************************************************************
/* 
Підтвердження закінчення
Перевірте, чи рядок (перший аргумент, str) закінчується заданим цільовим рядком (другий аргумент, target).
Це завдання можна вирішити за допомогою методу .endsWith(), який був введений в ES2015. Але ми б хотіли, 
щоб ви використали один із методів підрядків JavaScript. */

function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
}

confirmEnding("Bastian", "n");

//******************************************************************************************************************************
/* Повторення рядка Повторення рядка
Повторіть заданий рядок str (перший аргумент) num разів (другий аргумент). Поверніть порожній рядок, якщо num не є додатним числом. 
Не використовуйте вбудований метод .repeat() для цього завдання. */
function repeatStringNumTimes(str, num) {
  let multiString = "";
  for (let i = 0; i < num; i += 1) {
    multiString += str;
  }
  return multiString;
}

repeatStringNumTimes("abc", 3);

//recurcion solution
function repeatStringNumTimes(str, num) {
  return num < 1 ? "" : str + repeatStringNumTimes(str, num - 1);
}
//******************************************************************************************************************************
/* Скорочення рядка
Скоротіть рядок (перший аргумент), якщо він довший за максимальну довжину рядка (другий аргумент). Поверніть скорочений рядок із закінченням .... */

function truncateString(str, num) {
  return str.length > num ? str.slice(0, num) + "..." : str;
}

truncateString("A-tisket a-tasket A green and yellow basket", 8);
//******************************************************************************************************************************
/* Раз знайшов, значить моє
Створіть функцію, яка переглядає масив arr та повертає перший елемент у ньому, який проходить тест на «істинність». Це означає, що даний елемент x 
пройшов тест на «істинність», якщо func(x) є true. Якщо жодний елемент не проходить тест, поверніть undefined. */
function findElement(arr, func) {
  for (let i = 0; i < arr.length; i += 1) {
    if (func(arr[i])) {
      return arr[i];
    }
  }
  return undefined;
}

findElement([1, 2, 3, 4], (num) => num % 2 === 0);
//******************************************************************************************************************************

/* Бу, ти хто?
Перевірте, чи значення належить до булевого примітивного. Поверніть true або false.
Булеві примітивні значення: true (правда) та false (брехня). */
function booWho(bool) {
  return typeof bool === "boolean";
}

booWho(null);

//******************************************************************************************************************************
/* Слова З Великої Літери
Поверніть заданий рядок, де кожне слово починається з великої літери. Переконайтеся, що інші літери написані в нижньому регістрі.
Сполучні слова, як-от the та of, також потрібно писати з великої літери. */
function titleCase(str) {
  return str
    .split(" ")
    .map((item) => item[0].toUpperCase() + item.slice(1).toLowerCase())
    .join(" ");
}

titleCase("I'm a little tea pot");
//******************************************************************************************************************************
/* 
Slice та Splice
Вам надано два масиви та індекс.
Скопіюйте кожний елемент з першого масиву у другий за порядком.
Розпочніть вставляти елементи з індексу n другого масиву.
Поверніть отриманий масив. Вхідні масиви повинні залишатись незмінними після запуску функції. */
function frankenSplice(arr1, arr2, n) {
  return [...arr2.slice(0, n), ...arr1, ...arr2.slice(n)];
}

frankenSplice([1, 2, 3], [4, 5, 6], 1);

//******************************************************************************************************************************
/* Викидайло брехні
Видаліть всі неправильні значення з масиву. Поверніть новий масив; не змінюйте вихідний масив.
Неправильні значення в JavaScript: false, null, 0, "", undefined та NaN.
Підказка: спробуйте перетворити кожне значення у булеве. */
function bouncer(arr) {
  let trueArr = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (arr[i]) {
      trueArr.push(arr[i]);
    }
  }
  return trueArr;
}

bouncer([7, "ate", "", false, 9]);

//filter method
function bouncer(arr) {
  return arr.filter(Boolean);
}
//******************************************************************************************************************************
/* Куди я належу
Поверніть найменший індекс, при якому потрібно вставити значення (другий аргумент) в масив (перший аргумент), після того, як він був відсортований.
 Поверненим значенням повинне бути число.
Наприклад, getIndexToIns([1,2,3,4], 1.5) має повертати 1, оскільки він більший за 1 (індекс 0), але менший за 2 (індекс 1).
Аналогічно, getIndexToIns([20,3,5], 19) має повертати 2, оскільки після сортування масиву він виглядатиме як [3,5,20], а 19 менше за 20 (індекс 2) 
та більше за 5 (індекс 1). */
function getIndexToIns(arr, num) {
  arr.sort((a, b) => a - b);
  for (let i = 0; i < arr.length; i += 1) {
    if (arr[i] >= num) {
      return i;
    }
  }
  return arr.length;
}

getIndexToIns([40, 60], 50);
//using filter:
function getIndexToIns(arr, num) {
  return arr.filter((val) => num > val).length;
}
//using spread
function getIndexToIns(arr, num) {
  return [...arr, num].sort((a, b) => a - b).indexOf(num);
}

getIndexToIns([40, 60], 50);
//******************************************************************************************************************************
/* Мутації
Поверніть true, якщо рядок у першому елементі масиву містить усі літери рядка у другому елементі масиву.
Наприклад, ["hello", "Hello"] має повертати true, оскільки всі літери другого рядка наявні у першому, незважаючи на регістр.

Аргументи ["hello", "hey"] мають повертати false, оскільки рядок hello не містить y.

["Alien", "line"] має повертати true, оскільки всі літери в line наявні в Alien. */
function mutation(arr) {
  const test = arr[1].toLowerCase();
  const target = arr[0].toLowerCase();
  for (let i = 0; i < test.length; i += 1) {
    if (target.indexOf(test[i]) < 0) return false;
  }
  return true;
}

mutation(["hello", "hey"]);

//using chaining and every()
function mutation(arr) {
  return arr[1]
    .toLowerCase()
    .split("")
    .every((letter) => arr[0].toLowerCase().indexOf(letter) !== -1);
}
//******************************************************************************************************************************
/* Мавпочка Чанкі
Напишіть функцію, яка ділить масив (перший аргумент) на групи довжиною size (другий аргумент) та повертає їх як двовимірний масив. */
function chunkArrayInGroups(arr, size) {
  const result = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}

chunkArrayInGroups(["a", "b", "c", "d"], 2);
//******************************************************************************************************************************
/** */
